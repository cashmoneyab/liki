--[[
	@Author: Anna W. Anna W. <https://devforum.roblox.com/u/ImActuallyAnna> Skylar L. <https://devforum.roblox.com/u/ScobayDu>
	@Description: RBXM File Reader
	@Date of Creation: 09. 05. 2020

	Copyright (C) 2020 Kat Digital Limited.
	 
	This program is free software: you can redistribute it and/or modify  
	it under the terms of the GNU General Public License as published by  
	the Free Software Foundation, version 3.
	
	This program is distributed in the hope that it will be useful, but 
	WITHOUT ANY WARRANTY; without even the implied warranty of 
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
	General Public License for more details.
	
	You should have received a copy of the GNU General Public License 
	along with this program. If not, see <http://www.gnu.org/licenses/>
--]]

local _=script local j=(function()local k={} local _=table.insert local c=string.char local q=string.byte local n=string.sub local p=math.floor local b=math.ceil local j=math.abs local r=math.pow local d=math.log function k.bitwiseOr(a,_)return bit32.bor(a,_)end function k.bitwiseAnd(_,a)return bit32.band(_,a)end function k.bitwiseXor(a,_)return bit32.bxor(a,_)end function k.bitwiseNot(_)return 4294967295-_ end function k.byteNot(_)return 255-_ end function k.leftShift(a,_)return math.floor(a*math.pow(2,_))%4294967296 end function k.rightShift(a,_)return math.floor(a/math.pow(2,_))%4294967296 end function k.encodeInt(d,b)d=p(d)%r(256,b) local a={} for _=0,b-1 do a[b-_]=c(d%256) d=p(d/256)end return table.concat(a)end function k.decodeInt(b,_)if(_)then b=b:reverse()end local a=q(b,1) for _=2,#b do a=a*256+q(b,_)end return a end function k.decodeSignedInt(a,_)local b=k.decodeInt(a,_) local _=math.pow(256,#a) if(b<_/2)then return b end return-(_-b)end local _=d(2) local o=r(2,52) local e=r(2,23) local m=r(2,8) local l=r(2,16) local i=r(2,24) local h=r(2,32) local g=r(2,40) local f=r(2,48) function k.encodeDouble(e)local a=e<0 and 1 or 0 local _=b(d(j(e))/_)-1 local b=j(e)/r(2,_)-1 if(_<-1023)then _=-1023 b=j(e)/r(2,_)elseif(_>1024)then error("Exponent out of range: ".._)end if(e==0)then _=-1023 b=0 elseif(j(e)==math.huge)then _=1024 b=0 elseif(e~=e)then _=1024 b=(o-1)/o end local _=_+1023 local b=b*o return c(128*a+p(_/16),(_%16)*16+p(b/f),p(b/g)%256,p(b/h)%256,p(b/i)%256,p(b/l)%256,p(b/m)%256,p(b%256))end function k.decodeDouble(a,_)if(_)then a=a:reverse()end local j=q(n(a,1,1)) local k=q(n(a,2,2)) local e=q(n(a,3,3)) local d=q(n(a,4,4)) local c=q(n(a,5,5)) local b=q(n(a,6,6)) local _=q(n(a,7,7)) local a=q(n(a,8,8)) local n=j>=128 and 1 or 0 local j=(j%128)*16+p(k/16) local _=(k%16)*f+e*g+d*h+c*i+b*l+_*m+a if(j==2047)then if(_==0)then return r(-1,n)*math.huge end if(_==o-1)then return 0/0 end end if(j==0)then return r(-1,n)*r(2,j-1023)*(_/o)else return r(-1,n)*r(2,j-1023)*(_/o+1)end end function k.decodeFloat(d,_)if(_)then d=d:reverse()end local c=q(n(d,1,1)) local b=q(n(d,2,2)) local a=q(n(d,3,3)) local _=q(n(d,4,4)) local d=c>=128 and 1 or 0 local c=(c%128)*2+p(b/128) local _=(b%128)*l+a*m+_ if(c==255)then if(_==0)then return r(-1,d)*math.huge end if(_==e-1)then return 0/0 end end if(c==0)then return r(-1,d)*r(2,c-127)*(_/e)else return r(-1,d)*r(2,c-127)*(_/e+1)end end return k end)() local h=(function()local a={} a.__index=a function a.new(_)return setmetatable({Data=_;Position=1},a)end function a:read(a)if(self.Position>#self.Data)then return nil end if(a==nil)then a=1 end if(a==math.huge)then local _=self.Position self.Position=math.huge return self.Data:sub(_)end local _=self.Data:sub(self.Position,self.Position+(a-1)) self.Position=self.Position+a return _ end function a:lookAhead(_)if(self.Position>#self.Data)then return nil end local _=self.Data:sub(self.Position,self.Position+(_-1)) return _ end function a:readUntil(a)if(self.Position>#self.Data)then return nil end local _=self.Data:sub(self.Position) local a,_=_:find(a) if(a==nil)then local _=self.Position self.Position=#self.Data+1 return self.Data:sub(_),nil end local b=self.Position self.Position=self.Position+_ return self.Data:sub(b,b+(a-2)),self.Data:sub(b+(a-1),b+(_-1))end function a:readMatch(_)local _=self:lookAhead(#_):match("^(".._..")") self.Position=self.Position+#_ return _ end function a:skip(_)self.Position=self.Position+_ end function a:jumpBack(_)self.Position=math.max(self.Position-_,1)end function a:checkNext(_)return self:lookAhead(#_):match("^(".._..")")end function a:hasData()return self.Position<=#self.Data end return a end)() local d=(function()local _={} function _.decode(_)local d if(type(_)=="string")then d=h.new(_)else d=_ end local b=j.decodeInt(d:read(4),true) local e=j.decodeInt(d:read(4),true) assert(j.decodeInt(d:read(4),true)==0,"LZ4 E001: Invalid LZ4 header") local c=table.create(e,-1) local f=0 local function _(a)local _,_=1,#a for _=1,_ do assert(f+_<=e,"LZ4 E004: Too much uncompressed data") c[f+_]=string.byte(a,_)end f=f+_ end local function a(_,a)local _=(f-_)+1 local a=f+a+1 local _=_ local b=f+1 while(b<a)do c[b]=c[_] b=b+1 _=_+1 end f=b-1 end local d=h.new(d:read(b)) while true do local b=j.decodeInt(d:read(1)) local c=math.floor(b/16) local b=b%16 if(c==15)then local _ repeat _=j.decodeInt(d:read(1)) c=c+_ until _~=255 end if(c>0)then _(d:read(c))end if(d:hasData())then local _=j.decodeInt(d:read(2),true) assert(_~=0,"LZ4 E006: Offset can not be 0") if(b==15)then local _ repeat _=j.decodeInt(d:read(1)) b=b+_ until _~=255 end b=b+4 a(_,b)else break end end assert(f==e,"LZ4 E005: Uncompressed length is incorrect; expected "..e..", got "..f) local a={} for _=1,e,256 do local _=string.char(unpack(c,_,math.min(_+255,e))) table.insert(a,_)end return table.concat(a)end return _ end)() local e=string.byte local a=string.char local _=table.insert function compareByteArrays(_,b)if(#_~=#b)then return false end local _=a(unpack(_,1,#_)) local a=a(unpack(b,1,#b)) return _==a end function readString(a)local _=j.decodeInt(a:read(4),true) if(_==0)then return""end return a:read(_)end function setPropertyDirect(a,_,b)a[_]=b end local _={["size"]="Size";["Color3uint8"]="Color"} function setProperty(d,a,c)local b=_[a]or a local a,_=pcall(setPropertyDirect,d,b,c) if(not a)then if(d:IsA("BaseScript")and b=="Source")then print("Source: ") print(c)end end end function readInterleaved(b,a,c)local d=table.create(c,0) for _=1,c do d[_]=table.create(a,0)end for _=1,a do for a=1,c do d[a][_]=b:read(1)end end for _=1,c do d[_]=table.concat(d[_])end return d end function readRobloxInt(a,_)local _=j.decodeInt(a,_) if(_%2==0)then return _/2 else return-(_+1)/2 end end function readRobloxFloat(_)local _=j.decodeInt(_,false) local a=_%2 local _=j.encodeInt(a*0x80000000+(_-a)/2,4) return j.decodeFloat(_,false)end local c={[0x01]=Enum.NormalId.Front;[0x02]=Enum.NormalId.Bottom;[0x04]=Enum.NormalId.Left;[0x08]=Enum.NormalId.Back;[0x10]=Enum.NormalId.Top;[0x20]=Enum.NormalId.Right} local b={[0x00]=Vector3.new(0,0,0);[0x01]=Vector3.new(0,0,1);[0x02]=Vector3.new(0,1,0);[0x03]=Vector3.new(0,1,1);[0x04]=Vector3.new(1,0,0);[0x05]=Vector3.new(1,0,1);[0x06]=Vector3.new(1,1,0);[0x07]=Vector3.new(1,1,1)} local g=0 local a=math.pi/2 local _=math.pi local f=-math.pi/2 local a={[0x02]=CFrame.Angles(g,g,g);[0x03]=CFrame.Angles(a,g,g);[0x05]=CFrame.Angles(_,g,g);[0x06]=CFrame.Angles(f,g,g);[0x07]=CFrame.Angles(_,g,f);[0x09]=CFrame.Angles(a,a,g);[0x0A]=CFrame.Angles(g,g,a);[0x0C]=CFrame.Angles(f,f,g);[0x0D]=CFrame.Angles(f,g,f);[0x0E]=CFrame.Angles(g,f,g);[0x10]=CFrame.Angles(a,g,a);[0x11]=CFrame.Angles(_,a,g);[0x14]=CFrame.Angles(_,g,_);[0x15]=CFrame.Angles(f,g,_);[0x17]=CFrame.Angles(g,g,_);[0x18]=CFrame.Angles(a,g,_);[0x19]=CFrame.Angles(g,g,f);[0x1B]=CFrame.Angles(a,f,g);[0x1C]=CFrame.Angles(_,g,a);[0x1E]=CFrame.Angles(f,a,g);[0x1F]=CFrame.Angles(a,g,f);[0x20]=CFrame.Angles(g,a,g);[0x22]=CFrame.Angles(f,g,a);[0x23]=CFrame.Angles(_,f,g)} local g g={[0x01]=function(a,_)local b=table.create(a,"") for a=1,a do b[a]=readString(_)end return b end;[0x02]=function(_,a)local b=table.create(_,false) for _=1,_ do b[_]=a:read(1)~="\0"end return b end;[0x03]=function(b,_)local _=readInterleaved(_,4,b) local a=table.create(b,0) for b=1,b do a[b]=readRobloxInt(_[b])end return a end;[0x04]=function(b,_)local _=readInterleaved(_,4,b) local a=table.create(b,0) for b=1,b do a[b]=readRobloxFloat(_[b])end return a end;[0x05]=function(b,_)local _=readInterleaved(_,8,b) local a=table.create(b,0) for b=1,b do a[b]=j.decodeDouble(_[b]:reverse())end return a end;[0x06]=function(c,a)local _=readInterleaved(a,4,c) local a=readInterleaved(a,4,c) local b=table.create(c,0) for c=1,c do b[c]=UDim.new(readRobloxFloat(_[c]),readRobloxInt(a[c]))end return b end;[0x07]=function(e,a)local b=readInterleaved(a,4,e) local c=readInterleaved(a,4,e) local _=readInterleaved(a,4,e) local a=readInterleaved(a,4,e) local d=table.create(e,0) for e=1,e do d[e]=UDim2.new(readRobloxFloat(b[e]),readRobloxInt(_[e]),readRobloxFloat(c[e]),readRobloxInt(a[e]))end return d end;[0x08]=function(_,f)local g=table.create(_,0) for c=1,_ do local _=j.decodeFloat(f:read(4):reverse()) local a=j.decodeFloat(f:read(4):reverse()) local b=j.decodeFloat(f:read(4):reverse()) local d=j.decodeFloat(f:read(4):reverse()) local e=j.decodeFloat(f:read(4):reverse()) local f=j.decodeFloat(f:read(4):reverse()) g[c]=Ray.new(Vector3.new(_,a,b),Vector3.new(d,e,f))end return g end;[0x09]=function(a,_)local b=table.create(a,0) for a=1,a do local _=j.decodeInt(_:read(1)) local c=c[_] b[a]=c assert(c~=nil,"RBXMReader E007: Unknown surface type: ".._)end return b end;[0x0A]=function(a,_)local c=table.create(a,0) for a=1,a do local _=j.decodeInt(_:read(1)) local b=b[_] c[a]=b assert(b~=nil,"RBXMReader E008: Unknown axis type: ".._)end return c end;[0x0B]=function(c,b)local _=readInterleaved(b,4,c) local a=table.create(c,0) for _=1,c do a[_]=BrickColor.new(j.decodeInt(b:read(4)))end return a end;[0x0C]=function(d,b)local _=readInterleaved(b,4,d) local a=readInterleaved(b,4,d) local b=readInterleaved(b,4,d) local c=table.create(d,0) for d=1,d do c[d]=Color3.new(readRobloxFloat(_[d]),readRobloxFloat(a[d]),readRobloxFloat(b[d]))end return c end;[0x0D]=function(c,a)local _=readInterleaved(a,4,c) local a=readInterleaved(a,4,c) local b=table.create(c,0) for c=1,c do b[c]=Vector2.new(readRobloxFloat(_[c]),readRobloxFloat(a[c]))end return b end;[0x0E]=function(d,a)local _=readInterleaved(a,4,d) local b=readInterleaved(a,4,d) local a=readInterleaved(a,4,d) local c=table.create(d,0) for d=1,d do c[d]=Vector3.new(readRobloxFloat(_[d]),readRobloxFloat(b[d]),readRobloxFloat(a[d]))end return c end;[0x10]=function(e,d)local c=table.create(e,CFrame.new()) local b=table.create(e,CFrame.new()) for b=1,e do local _=j.decodeInt(d:read(1)) local _=a[_] if(_==nil)then local a=table.create(9,0) for _=1,9 do a[_]=j.decodeFloat(d:read(4),true)end c[b]=CFrame.new(0,0,0,unpack(a,1,9))else c[b]=_ end end local _=g[0x0E](e,d) for a=1,e do b[a]=CFrame.new(_[a])*c[a]end return b end;[0x11]=function(_,a)warn("RBXMReader W001: Using quaternions") return g[0x10](_,a)end;[0x12]=function(a,_)local _=readInterleaved(_,4,a) local b=table.create(a,0) for a=1,a do b[a]=j.decodeInt(_[a])end return b end;[0x13]=function(d,_,a)local _=readInterleaved(_,4,d) local c=table.create(d,0) local b=0 for d=1,d do local _=readRobloxInt(_[d]) local _=_+b b=_ c[d]=a[_]end return c end;[0x1A]=function(e,d)local b=table.create(e,0) local c=table.create(e,0) local a=table.create(e,0) local _=table.create(e,0) for _=1,e do b[_]=j.decodeInt(d:read(1))end for _=1,e do c[_]=j.decodeInt(d:read(1))end for _=1,e do a[_]=j.decodeInt(d:read(1))end for d=1,e do _[d]=Color3.fromRGB(b[d],c[d],a[d])end return _ end} function ReadRBXM(_)local c=h.new(_) local _={e(c:read(16),1,16)} local a={0x3C,0x72,0x6F,0x62,0x6C,0x6F,0x78,0x21,0x89,0xFF,0x0D,0x0A,0x1A,0x0A,0x00,0x00} assert(compareByteArrays(_,a),"RBXMReader E001: Invalid RBXM header") local b=Instance.new("Model") local _=j.decodeInt(c:read(4),true) local _=j.decodeInt(c:read(4),true) assert(j.decodeInt(c:read(4))==0,"RBXMReader E002: Invalid RBXM header") assert(j.decodeInt(c:read(4))==0,"RBXMReader E002: Invalid RBXM header") local a={} local _={} local f={} local i={} while true do local _=c:lookAhead(4) if(_=="PROP")then break end local _=c:read(4) local c=h.new(d.decode(c)) if(_=="META")then local b,_=j.decodeInt(c:read(4),true),0 for _=1,b do local _=readString(c) local b=readString(c) a[_]=b end elseif(_=="SSTR")then elseif(_=="INST")then local e=j.decodeInt(c:read(4),true) local d=readString(c) local b=c:read(1)~="\0" local h=j.decodeInt(c:read(4),true) local a=readInterleaved(c,4,h) assert(not b,"RBXMReader E004: File contains services") local c,_,g=table.create(h,0),1,0 for _=1,h do g=g+readRobloxInt(a[_]) local a=Instance.new(d) c[_]=a i[g]=a end f[e]={Index=e;ClassName=d;IsService=b;InstanceCount=h;Instances=c}else error("RBXMReader E003: Unexpected header object type: ".._)end end while true do local _=c:read(4) local e=h.new(d.decode(c)) if(_=="PROP")then local a=j.decodeInt(e:read(4),true) local b=readString(e) local _=j.decodeInt(e:read(1)) local a=f[a] local d=a.InstanceCount local c=a.Instances local _=g[_] if(_~=nil)then local a=_(d,e,i) local _ for _=1,d do setProperty(c[_],b,a[_])end else end elseif(_=="PRNT")then e:read(1) local c=j.decodeInt(e:read(4),true) local a=readInterleaved(e,4,c) local _=readInterleaved(e,4,c) local d=0 local e=0 for c=1,c do d=d+readRobloxInt(a[c]) e=e+readRobloxInt(_[c]) local _=i[d] if(e==-1)then _.Parent=b else _.Parent=i[e]end end break else error("RBXMReader E005: File contains unexpected body element: ".._)end end local _={0x45,0x4E,0x44,0x00,0x00,0x00,0x00,0x00,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x2F,0x72,0x6F,0x62,0x6C,0x6F,0x78,0x3E} local a={e(c:read(25),1,25)} assert(compareByteArrays(a,_),"RBXMReader E006: Invalid RBXM footer") return b end return{ReadRBXM=ReadRBXM}
